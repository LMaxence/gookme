{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome on Gookme","text":"<p>A simple and easy-to-use, yet powerful and language agnostic git hook for monorepos.</p>"},{"location":"#what-is-gookme","title":"What is Gookme ?","text":"<p>Gookme is a Git hook manager. It's sole purpose is to execute some scripts when you want to commit or do other git stuff. It could be a linter, tests, your favorite commit message checker.</p> <p>What can I run with Gookme ?</p> <p>Everything that is invoked through a cli can be used with Gookme!</p> <p>You are welcome to use it and enjoy it's simplicity. If you encounter any bug or weird behavior, don't be afraid to open an issue :)</p>"},{"location":"#how-does-it-work","title":"How does it work ?","text":"<ol> <li>Gookme is invoked by a git hook script</li> <li>Gookme looks for <code>hooks</code> folders across your repository</li> <li>For each detected folders, Gookme detects if there are any hooks defined for the git hook currently being executed</li> <li>For each detected folders, Gookme detects if there are git-staged changes in this folder</li> <li>If both conditions above are valid, Gookme runs concurrently (or not) the different commands provided in the hook files.</li> </ol>"},{"location":"#why-not","title":"Why not ... ?","text":""},{"location":"#bash-scripts","title":"<code>bash</code> scripts","text":"<p><code>bash</code> scripts directly written in my <code>.git/hooks</code> folder</p> <ul> <li>Even if it is true that, in the end, <code>Gookme</code> will do nothing more than invoking commands the exact same way a bash script would, the <code>.git/hooks</code> folder is a not a versioned one, hence it will prevent you from sharing configuration.</li> <li><code>Gookme</code> provides you with a way to version these hooks, and to share repository configuration among the rest of your team.</li> <li>The hook setup is a one liner for the new developers landing in your team. It won't download anything, just write a small line in your <code>.git/hooks</code> files</li> </ul>"},{"location":"#pre-commit","title":"<code>pre-commit</code>","text":"<p>Info</p> <p><code>pre-commit</code> was the tool I used before developing Mookme, then Gookme.</p> <p>There were several issues with <code>pre-commit</code>, that led me to develop my own tool :</p> <ul> <li>pre-commit is not designed for monorepos, hence most of the hooks are some sort of hacks</li> <li>per-package environment is not easy to manage, because <code>pre-commit</code> has it's own global environment and we have to create global dependency to run a particular hook for one package.</li> </ul> <p>Warning</p> <p>This led us to one of the guideline used by <code>Gookme</code> to work: If we run a hook on a package in your monorepo it means:</p> <ul> <li>There are changes in the folder of this package</li> <li>The dev environment of this package is properly installed (Gookme does not proceed to any additional setup)</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#commitlint","title":"<code>commitlint</code>","text":"<p>This guide will help you in the setup of a hook a hook for linting your commits with commitlint</p>"},{"location":"examples/#prerequisite-for-commitlint","title":"Prerequisite for Commitlint","text":"<ul> <li>You have installed <code>Gookme</code></li> <li>You have installed and configured commitlint</li> <li>You have setup <code>Gookme</code> using <code>gookme init</code> (see get started if needed)</li> </ul>"},{"location":"examples/#hook-for-commitlint","title":"Hook for Commitlint","text":"<p>In the global hooks folder of your project <code>hooks/commit-msg.json</code> add the following configuration :</p> hooks/commit-msg.json<pre><code>{\n    \"steps\": [\n        // ...\n        // your other steps\n        {\n            \"name\": \"Lint commit message\",\n            \"command\": \"npx commitlint --edit $1\"\n        }\n        // ...\n        // your other steps\n    ]\n}\n</code></pre>"},{"location":"examples/#running-multiple-steps-sequentially","title":"Running multiple steps sequentially","text":"<p>It is possible to run multiple steps sequentially by setting the <code>serial</code> option to <code>true</code>. When a step is set to <code>serial</code>, the next step will only be executed when the step marked as <code>serial</code> has succeeded. Previous steps will be executed in parallel unless they are also set to <code>serial</code>.</p> hooks/commit-msg.json<pre><code>{\n  \"steps\": [\n    {\n      \"name\": \"go vet\",\n      \"command\": \"go vet ./...\",\n      \"serial\": true\n    },\n    {\n      \"name\": \"format go code\",\n      \"command\": \"go fmt ./...\",\n      \"serial\": true\n    },\n    {\n      \"name\": \"test go code\",\n      \"command\": \"go test ./...\",\n      \"serial\": true\n    },\n    {\n      \"name\": \"lint go code\",\n      \"command\": \"golangci-lint run ./...\",\n      \"serial\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#reusable-steps","title":"Reusable steps","text":"<p><code>Gookme</code> provides you with step-sharing features, allowing you to declare shared step example, and to use them in your steps.</p> <p>Given a project directory such as this:</p> Project structure<pre><code>project-root\n|--- hooks\n    |--- shared\n        |--- flake8.json\n|--- packages\n    |--- some-package\n        |--- hooks\n            |--- pre-commit.json\n</code></pre> <p>Tip</p> <p>The <code>hooks/shared</code> folder is automatically generated with a <code>.gitkeep</code> file by <code>gookme init</code>.</p> <p>You can declare a step in <code>hooks/shared/flake8.json</code> ...</p> hooks/shared/flake8.json<pre><code>{\n  \"name\": \"Ensure Style (flake8)\",\n  \"command\": \"flake8 $(python-module) --ignore E203,W503 --max-line-length 90\",\n  \"onlyOn\": \"**/*.py\"\n}\n</code></pre> <p>... and then re-use it in <code>some-package/hooks/pre-commit.json</code> with the <code>from</code> keyword:</p> some-package/hooks/pre-commit.json<pre><code>{\n  \"steps\": [\n    {\n      \"from\": \"flake8\"\n    },\n    ... // some other steps\n  ]\n}\n</code></pre>"},{"location":"features/#writing-and-using-utils-scripts","title":"Writing and using utils scripts","text":"<p>It is possible to declare some scripts in the project root <code>Gookme</code> hooks folder, and then use them directly in the commands invoked by the steps.</p> <p>Given a project directory such as this:</p> Project structure<pre><code>project-root\n|--- .mookme.json\n|--- hooks\n    |--- partials\n        |--- pylint-changed-files\n |--- packages\n    |--- some-package\n        |--- .hooks\n            |--- pre-commit.json\n</code></pre> <p>Here is how the <code>python-changed-files</code> script looks like</p> project-root/hooks/partials/pylint-changed-files<pre><code>#!/usr/bin/env bash\ngit --no-pager diff --cached --name-only --diff-filter=AM --relative -- \"***.py\" | tr '\\n' '\\0' | xargs -0 \"$@\"\n</code></pre> <p>Tip</p> <p>The <code>hooks/partials</code> is automatically generated with a <code>.gitkeep</code> file by <code>gookme init</code>.</p> <p>One can declare a script in flake8 (don't forget to <code>chmod+x</code>) and then re-use it in <code>some-package/hooks/pre-commit.json</code> by directly invoking the script's name:</p> some-package/hooks/pre-commit.json<pre><code>{\n  \"steps\": [\n    {\n      \"name\": \"Run pylint but only on changed files\",\n      \"command\": \"python-changed-files pylint\"\n    },\n    ... // some other steps\n  ]\n}\n</code></pre>"},{"location":"features/#use-a-range-of-commits","title":"Use a range of commits","text":"<p>Using the Gookme CLI, it is possible to invoke a set of hooks and steps selected using the files changed between two git references.</p> <pre><code>gookme run -t pre-commit --from HEAD~1 --to f9ff43\ngookme run -t pre-commit --from HEAD~25 --to d58688dd611ef01079f61ebae36df0ce8c380ddb\n</code></pre> <p>You can find more details about these options on the gookme run reference page.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"LinuxMacOSWindows Install Gookme<pre><code>curl -sSL https://raw.githubusercontent.com/LMaxence/gookme/main/scripts/install.sh | bash\n</code></pre> Install Gookme<pre><code>curl -sSL https://raw.githubusercontent.com/LMaxence/gookme/main/scripts/install.sh | bash\n</code></pre> Install Gookme<pre><code>Invoke-WebRequest -Uri https://raw.githubusercontent.com/LMaxence/gookme/main/scripts/install.ps1 -OutFile install.ps1\n.\\install.ps1\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Gookme will automatically detect the <code>hooks</code> folder across your repository and trigger the command related to your current VCS state.</p> <p>Hence it only requires a very minimal configuration, as most of this is defined by where you place your <code>hooks</code> folders, and what you put in them.</p>"},{"location":"getting-started/#setup-git-to-run-gookme","title":"Setup Git to run Gookme","text":"<p>To setup Gookme, you need to create scripts in the <code>.git/hooks</code> folder, or add a few lines in the existing ones. This is done automatically by running the <code>init</code> command</p> Initialize Gookme with all Git hooks<pre><code>gookme init --all\n</code></pre>"},{"location":"getting-started/#selectively-setup-gookme","title":"Selectively setup Gookme","text":"<p>If you want to only setup the hooks for a specific hook type, you can use the <code>--types</code> option of the <code>gookme init</code> command.</p> Initialize Gookme with pre-commit and commit-msg hooks<pre><code>gookme init --types pre-commit,commit-msg\n</code></pre>"},{"location":"getting-started/#removing-gookme-from-your-git-hooks-scripts","title":"Removing Gookme from your Git hooks scripts","text":"<p>If you want to remove Gookme from your Git hooks scripts, you can use the <code>clean</code> command.</p> Remove Gookme from your Git hooks scripts<pre><code>gookme clean\n</code></pre> <p>This will remove all the lines added by Gookme in your Git hooks scripts.</p>"},{"location":"getting-started/#writing-your-hooks","title":"Writing your hooks","text":""},{"location":"getting-started/#global-structure-of-your-project-hooks","title":"Global structure of your project hooks","text":"<p><code>Gookme</code> is designed for monorepos, hence it assumes your project has a root folder where global hooks can be defined, and multiple packages where you can define per-package hook.</p> <p>Tip</p> <p>Hooks are written in a folder <code>hooks</code> located at the root of your project and at the root of your packages' folders.</p> <p>When using <code>Gookme</code> in a monorepo, you will have a project structure following this :</p> <pre><code>&lt;root&gt; # where your .git is located\n|- hooks # will always be executed when you commit\n|  |- pre-commit.json # will be executed with the pre-commit git hook\n|  |- commit-msg.json  # will be executed with the commit-msg git hook\n|  |- prepare-commit-msg.json\n|  |- post-commit.json\n|- packages\n|  |- package A\n|  |  |- hooks # will be executed if you commit changes on package A\n|  |  |  |- pre-commit.json\n|  |  |  |- post-commit.json\n|  |- package A\n|  |  |- hooks # will be executed if you commit changes on package B\n|  |  |  |- pre-commit.json\n</code></pre> <p>With <code>Gookme</code>, your hooks are stored in JSON files called <code>{hook-type}.json</code> where the hook type is one of the available git hooks, eg :</p> <ul> <li><code>pre-commit</code></li> <li><code>prepare-commit-msg</code></li> <li><code>commit-msg</code></li> <li><code>post-commit</code></li> <li><code>post-merge</code></li> <li><code>post-rewrite</code></li> <li><code>pre-rebase</code></li> <li><code>post-checkout</code></li> <li><code>pre-push</code></li> </ul> <p>Warning</p> <p>If the command executed by a hook fails, it will prevent the git command to be executed. We recommend you to use the pre-receive hooks carefully, with relatively safe commands, otherwise you might prevent your team for doign stuff like <code>git pull</code> or <code>git fetch</code>.</p>"},{"location":"getting-started/#how-will-gookme-decide-which-hooks-to-run","title":"How will Gookme decide which hooks to run ?","text":"<ol> <li> <p>Gookme will pick up files concerned by an execution. The result of this step is a list of relative paths from the root of the repository.</p> </li> <li> <p>For each folder where a <code>hooks</code> folder is found, Gookme will assess if there are file paths in the previous list matching the relative path to this folder from the root of the repository.</p> </li> <li> <p>Other selections (<code>onlyOn</code> for instance) are applied on each step of each package, based on the list of paths attached to the package and it's steps.</p> </li> </ol> <p>Tip</p> <p>Depending on the hook type being executed, or the arguments passed to the command, the list of paths can be different.</p> <ul> <li>The hook type <code>pre-push</code> will consider the list of files to be pushed to the remote server</li> <li>The hook type <code>post-commit</code> will consider the list of files included in the last commit</li> <li>If the <code>run</code> command argument --from and --to are used, the list of paths will be the list of files changed between the two commits</li> <li>All other hook types will use the list of files changed in the current commit, and staged</li> </ul>"},{"location":"getting-started/#example-of-hook-file","title":"Example of hook file","text":"<p>Your hooks are defined in simple json files.</p> <ul> <li>For complete reference, see the JSON hooks reference</li> <li>For specific hook examples, see the recipes</li> </ul> <p>A hook defines a list of <code>steps</code>, which are basically commands to run, with a name for proper display. A few configuration options are available, but the minimal requirement is <code>name</code> and <code>command</code>.</p> <p>Here is an example that will run your commit message using <code>commitlint</code>.</p> hooks/commit-msg.json<pre><code>{\n    \"steps\": [{\n        \"name\": \"Lint commit message\",\n        \"command\": \"commitlint lint --message $1\"\n    }]\n}\n</code></pre> <p>Tip</p> <p>When writing package-scoped hooks, the current working directory assumed by <code>Gookme</code> is the folder where this package's <code>hooks'</code> folder is located</p> <p>Warning</p> <p>The token <code>$1</code> in the hook command is replaced with the hook arguments when the command is executed. See the  Git documentation on hooks</p> <p>More examples to get you started!</p>"},{"location":"reference/","title":"CLI &amp; references","text":""},{"location":"reference/#gookme-init","title":"<code>gookme init</code>","text":"<p>The main initialization command. It :</p> <ul> <li>creates a <code>hooks</code> folder at the root of your project where you can write project-wide hooks that will be triggered on every commit</li> <li>writes <code>.git/hooks</code> files</li> </ul>"},{"location":"reference/#options-for-gookme-init","title":"Options for <code>gookme init</code>","text":"option short description --types -t The types of Git hooks to hook. Accepted values are: pre-commit,  prepare-commit-msg, commit-msg,  post-commit, post-merge, post-rewrite,  pre-rebase, post-checkout, pre-push --all -a Initialize all available hooks. Has precedence over the --types flag"},{"location":"reference/#examples-for-gookme-init","title":"Examples for <code>gookme init</code>","text":"Initialize Gookme with pre-commit and commit-msg hooks<pre><code>gookme init --types pre-commit,commit-msg\n</code></pre> Initialize Gookme with all available hooks<pre><code>gookme init --all\n</code></pre>"},{"location":"reference/#gookme-run","title":"<code>gookme run</code>","text":"<p>Mainly used for debugging and dry run :</p>"},{"location":"reference/#options-for-gookme-run","title":"Options for <code>gookme run</code>","text":"option short description --type -t The types of Git hook to run. Accepted values are: pre-commit,  prepare-commit-msg, commit-msg,  post-commit, post-merge, post-rewrite,  pre-rebase, post-checkout, pre-push --from -f (optional) Starting git reference used to evaluate hooks to run. If set, <code>to</code> has to be set as well, otherwise this option is ignored. --to -o (optional) Ending git reference used to evaluate hooks to run. If set, <code>from</code> has to be set as well, otherwise this option is ignored."},{"location":"reference/#examples-for-gookme-run","title":"Examples for <code>gookme run</code>","text":"Run all hooks for the pre-commit type<pre><code>gookme run --type pre-commit &lt;args&gt;\n</code></pre>"},{"location":"reference/#hook-files","title":"Hook files","text":""},{"location":"reference/#general-description","title":"General description","text":"<p>See Writing your hooks</p>"},{"location":"reference/#available-options","title":"Available options","text":"<ul> <li><code>steps</code></li> </ul> <p>The list of steps (commands) being executed by this hook. In a step you can define :</p>"},{"location":"reference/#step-options","title":"Step options","text":"Option Description Required <code>name</code> The name that will be given to this step yes <code>command</code> The command invoked at this step yes <code>onlyOn</code> A shell wildcard (or a list of wildcard) conditioning the execution of the step based on modified files no <code>serial</code> A boolean value describing if the package hook execution should await for the step to end no <code>from</code> Extend a shared step no <p>Warning</p> <p>Gookme exits with a non-zero status code if any of the steps fails, as soon as one fails.</p> <p>Warning</p> <p>The pattern provided in <code>onlyOn</code> will be matched agains the relative path of matched files of the execution, from the package folder, not from the repository root.</p>"},{"location":"reference/#available-arguments","title":"Available arguments","text":"<p>A set of arguments is provided by Mookme, that can be directly used in the hooks command definitions using the following syntax in the step definition:</p> hooks/commit-msg.json<pre><code>{\n    \"command\": \"run-something $1\" // (1)!\n    \"command\": \"run-something $MATCHED_FILES\" // (2)!\n    \"command\": \"run-something $PACKAGE_FILES\" // (3)!\n}\n</code></pre> <ol> <li> <p>The argument being passed by git to the hook file. See the Git documentation on the hooks for more details about what it contains depending on the hook type being executed.</p> </li> <li> <p>The list of changed files matched by the onlyOn option of this step, separated by a space. If the onlyOn option is not set, it will be replaced with an empty string.</p> </li> <li> <p>The list of changed files in the package folder, separated by a space.</p> </li> </ol>"}]}